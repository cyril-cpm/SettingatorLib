#include "HTTPServer.h"
#include <ESPAsyncWebServer.h>
#include <SPIFFS.h>

String HTML_CONTENT = "<style>\nbody {\n  background-color: #000;\n  margin: 100px auto;\n  text-align: center;\n}\n\nbutton,\nh1 {\n  color: #fff;\n  font-family: helvetica;\n  font-size: 190%;\n  font-style: italic;\n  letter-spacing: 2px;\n}\n\nh1 {\n  margin-bottom: 60px;\n  position: absolute;\n  width: 100%;\n  pointer-events: none;\n}\n\ninput[type=range] {\n  -webkit-appearance: none;\n  width: 90%;\n  height: 15px;\n  background: #000;\n  outline: none;\n  border: 5px solid rgb(0, 255, 0);\n  border-radius: 8px;\n  margin-top: 30px;\n  margin-bottom: 30px;\n}\n\n\n/* for chrome/safari */\ninput[type=range]::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  appearance: none;\n  width: 20px;\n  height: 60px;\n  background: #000;\n  cursor: pointer;\n  border: 5px solid rgb(0, 255, 0);\n  border-radius: 4px;\n}\n\n/* for firefox */\ninput[type=range]::-moz-range-thumb {\n  width: 20px;\n  height: 60px;\n  background: #000;\n  cursor: pointer;\n  border: 5px solid lawngreen;\n  border-radius: 4px;\n}\n\ninput[type=checkbox] {\n    -webkit-appearance: none;\n    width: 90%;\n    height: 60px;\n    background-color: rgb(0, 255, 0);\n    align-self: center;\n}\n\ninput[type=checkbox]:checked {\n    background-color: rgb(255, 0, 0);\n}\n\nbutton {\n    width: 90%;\n    height: 60px;\n    background-color: rgb(0, 255, 0);\n}\n\nbutton:active {\n    background-color: rgb(255, 0, 0);\n}\n\n</style>\n\n<h1>Debug</h1>\n<input type=\"checkbox\" id=\"debugSwitch\"/>\n\n<textarea id=\"log\" name=\"log\" rows=\"20\" cols=\"120\"></textarea>\n<script>\n\n    let log = document.getElementById(\"log\");\n    log.remove();\n    log.scrollTop = log.scrollHeight;\n\n    SLIDER = 0x01;\n    TRIGGER = 0X02;\n    SWITCH = 0x03;\n    LABEL = 0x04;\n\n    SETTING_UPDATE = 0x11;\n    SETTING_INIT = 0x13;\n\n    function logText(text) {\n        log.textContent += text + \"\\n\";\n    }\n    \n    function logHex(buff) {\n        for (i = 0; i < buff.length; i++) {\n            if (buff[i] < 16)\n                log.textContent += 0;\n            log.textContent += buff[i].toString(16);\n            log.textContent += \" \";\n        }\n        log.textContent += \"\\n\";\n    }\n\n    webSocket = new WebSocket(\"ws://192.168.0.1:8081/settingator\", \"settingator\");\n    webSocket.binaryType = \"arraybuffer\";\n\n    \n    function sendMessage(message) {\n        logText(\"Sending Message:\");\n        logHex(message);\n        webSocket.send(message);\n    }\n\n\n    function sendInitRequest() {\n        let initRequest = new Uint8Array([ 0xFF, 0x00, 0x06, 0x12, 0x00, 0x00]);\n        sendMessage(initRequest);\n        logText(\"Init request sent...\");\n    }\n\n    function setSliderColor(setting, newValue) {\n        switch (setting.name) {\n            case \"red\":\n                setting.node.style = \"border-color: rgb( 100%, 0%, 0%, \" + newValue/255 + \");\";\n                break;\n            case \"green\":\n                setting.node.style = \"border-color: rgb(0%, 100%, 0%, \" + newValue/255 + \");\";\n                break;\n            case \"blue\":\n                setting.node.style = \"border-color: rgb(0%, 0%, 100%, \" + newValue/255 + \");\";\n                break;\n            case \"white\":\n                setting.node.style = \"border-color: rgb(100%, 100%, 100%, \" + newValue/255 + \");\";\n                break;\n        }\n    }\n\n    function addSetting(setting) {\n            if (setting.type == SLIDER) {\n                let node = document.createElement(\"input\");\n                setting.node = node;\n\n                node.type = \"range\";\n                node.min = 0;\n                node.max = Math.pow(256, setting.valueSize) - 1;\n                node.id = setting.refId;\n\n                node.value = 0;\n                for (let i = 0; i < setting.valueSize; i++) {\n                    node.value = node.value * 256;\n                    node.value += setting.value[i];\n                }\n                node.oldValue = node.value;\n\n                node.addEventListener(\"change\", function() {\n                    let newValue = node.value;\n                    \n                    if (newValue != node.oldValue) {\n                        node.oldValue = node.value;\n                        logText(newValue);\n\n                        let updateMsg = [ 0xFF];\n                        let messageSize = 7 + setting.valueSize;\n\n                        updateMsg[1] = Math.floor(messageSize / 256);\n                        updateMsg[2] = messageSize % 256;\n                        updateMsg[3] = SETTING_UPDATE;\n                        updateMsg[4] = setting.ref;\n                        updateMsg[5] = setting.valueSize;\n                        \n                        for (i = setting.valueSize - 1; i >= 0; i--) {\n                            updateMsg[6 + i] = newValue % 256;\n                            newValue = Math.floor(newValue / 256);\n                        }\n\n                        updateMsg[6 + setting.valueSize] = 0x00;\n\n                        sendMessage(new Uint8Array(updateMsg));\n                    }\n                });\n\n                node.oninput = function() {\n                    setSliderColor(setting, node.value);\n                };\n\n                setSliderColor(setting, setting.value);\n                //node.getElementById(\"track\").style = \"border-color: \" + setting.name + \";\";\n                document.styleSheets.item(0).addRule(\"#\" + setting.refId + \"::-webkit-slider-thumb\", \"border-color: \" + setting.name +\";\");\n                document.body.appendChild(node);\n            }\n            else if (setting.type == SWITCH) {\n                let labelNode = document.createElement(\"h1\");\n                labelNode.innerText = setting.name;\n                let inputNode = document.createElement(\"input\");\n                inputNode.type = \"checkbox\";\n\n                inputNode.oninput = function() {\n                      \n                    let updateMsg = [0xFF,\n                                    0x00,\n                                    0x08,\n                                    SETTING_UPDATE,\n                                    setting.ref,\n                                    0x01,\n                                    inputNode.checked == true ? 0x01 : 0x00,\n                                    0x00];\n\n                    sendMessage(new Uint8Array(updateMsg));\n                };\n\n                document.body.appendChild(labelNode);\n                document.body.appendChild(inputNode);\n            }\n            else if (setting.type == TRIGGER) {\n                let buttonNode = document.createElement(\"button\");\n                buttonNode.innerText = setting.name;\n\n                buttonNode.onclick = function() {\n                    let updateMsg = [0xFF,\n                                    0x00,\n                                    0x00,\n                                    SETTING_UPDATE,\n                                    setting.ref,\n                                    0x00,\n                                    0x00];\n                        \n                    sendMessage(new Uint8Array(updateMsg));\n                }\n\n                document.body.appendChild(buttonNode);\n            }\n            else if (setting.type = LABEL) {\n                let labelNode = document.createElement(\"h1\");\n                labelNode.id = setting.refId\n                labelNode.innerText = new TextDecoder().decode(setting.value);\n\n                document.body.appendChild(labelNode);\n            }\n}\n\n    function treatMessage(message) {\n        let view = new Uint8Array(message);\n        logHex(view);\n\n        let msg = {};\n\n        msg.size = (view[1] << 8) + view[2];\n        msg.type = view[3];\n\n        if (msg.type == SETTING_INIT) {\n            msg.nbSettings = view[4];\n\n            let settingView = view.slice(5);\n\n            for (let i = 0; i < msg.nbSettings; i++) {\n                let setting = {};\n\n                setting.ref = settingView[0];\n                setting.refId = \"ref\" + setting.ref;\n                setting.type = settingView[1];\n                setting.valueSize = settingView[2];\n                setting.value = settingView.slice(3, 3 + setting.valueSize);\n                setting.nameLen = settingView[3 + setting.valueSize];\n                setting.name = new TextDecoder().decode(settingView.slice(3 + setting.valueSize + 1, 3 + setting.valueSize + 1 + setting.nameLen));\n\n                settingView = settingView.slice(3 + setting.valueSize + 1 + setting.nameLen);\n\n                addSetting(setting);\n                logText(setting.name);\n            }\n        }\n        else if (msg.type == SETTING_UPDATE) {\n            let ref = view[4];\n            let len = view[5];\n            let val = view.slice(6, 6 + len);\n\n            let node = document.getElementById(\"ref\" + ref);\n\n            node.innerText = new TextDecoder().decode(val);\n        }\n\n        return;\n    }\n\n    webSocket.onopen = function (event) {\n        logText(\"onOpen\");\n\n        sendInitRequest();\n    }\n\n    webSocket.onclose = function (event) {\n        logText(\"onClose \" + event.code + \" \" + event.reason);\n    }\n\n    webSocket.onmessage = function (event) {\n        logText(\"onMessage\");\n\n        treatMessage(event.data);\n    }\n\n    webSocket.onerror = function (event) {\n        logText(\"onError\");\n    }\n    \n    let debugSwitch = document.getElementById(\"debugSwitch\");\n    debugSwitch.onchange = function() {\n        if (debugSwitch.checked == true) {\n            debugSwitch.parentNode.insertBefore(log, debugSwitch.nextElementSibling);\n        }\n        else {\n            log.remove();\n        }\n    }\n\n\n</script>";

HTTPServer::HTTPServer(uint16_t port)
{
    if(!SPIFFS.begin(true)){
        Serial.println("An Error has occurred while mounting SPIFFS");
        return;
      }

    fServer = new AsyncWebServer(port);

    fServer->on("/*", HTTP_GET, [](AsyncWebServerRequest *request) {
      Serial.println("http request received");
      Serial.println(request->url());
      Serial.println(request->host());
      Serial.println(request->contentType());
      request->send(200, "text/html", HTML_CONTENT);
    });

    Serial.println("Begin Web Server");
    Serial.print("port: ");
    Serial.println(port);
    fServer->begin();
    Serial.println("finish");
}

HTTPServer::~HTTPServer()
{
    delete fServer;
}